// Generated by LiveScript 1.4.0
(function(){
  var mongoose, crypto, _, Schema, authTypes, UserSchema, validatePresenceOf;
  mongoose = require('mongoose');
  crypto = require('crypto');
  _ = require('lodash');
  Schema = mongoose.Schema;
  authTypes = ['userapp', 'soundcloud'];
  UserSchema = new Schema({
    __v: {
      type: Number,
      select: false
    },
    _label: {
      type: Number,
      ref: 'Label'
    },
    name: {
      type: String,
      'default': ''
    },
    email: {
      type: String,
      'default': ''
    },
    username: {
      type: String,
      'default': ''
    },
    lang: {
      type: String,
      'default': 'en_EN'
    },
    account_type: {
      type: String,
      'default': 'user'
    },
    role: {
      type: String
    },
    label: {
      _label: {
        type: Number,
        ref: 'Label'
      },
      name: {
        type: String
      }
    },
    avatar: {
      type: String,
      'default': ''
    },
    image: {
      name: {
        type: String,
        'default': ''
      }
    },
    provider: {
      type: String,
      'default': ''
    },
    hashed_password: {
      type: String,
      'default': ''
    },
    salt: {
      type: String,
      'default': ''
    },
    authToken: {
      type: String,
      'default': ''
    },
    soundcloud: {}
  });
  UserSchema.virtual('password').set(function(password){
    this._password = password;
    this.salt = this.makeSalt();
    this.hashed_password = this.encryptPassword(password);
  }).get(function(){
    return this._password;
  });
  validatePresenceOf = function(value){
    return value && value.length;
  };
  UserSchema.path('name').validate(function(name){
    if (authTypes.indexOf(this.provider) !== -1) {
      return true;
    }
    return name.length;
  }, 'Name cannot be blank');
  UserSchema.path('email').validate(function(email){
    if (authTypes.indexOf(this.provider) !== -1) {
      return true;
    }
    return email.length;
  }, 'Email cannot be blank');
  UserSchema.path('email').validate(function(email, fn){
    var User;
    User = mongoose.model('User');
    if (this.isNew || this.isModified('email')) {
      User.find({
        email: email
      }).exec(function(err, users){
        fn(err) || users.length === 0;
      });
    } else {
      fn(true);
    }
  }, 'Email already exists');
  UserSchema.path('username').validate(function(username){
    if (authTypes.indexOf(this.provider) !== -1) {
      return true;
    }
    return username.length;
  }, 'Username cannot be blank');
  UserSchema.path('username').validate(function(username, fn){
    var User;
    User = mongoose.model('User');
    if (this.isNew || this.isModified('username')) {
      User.find({
        username: username
      }).exec(function(err, users){
        fn(err) || users.length === 0;
      });
    } else {
      fn(true);
    }
  }, 'Username already exists');
  UserSchema.path('hashed_password').validate(function(hashed_password){
    if (authTypes.indexOf(this.provider) !== -1) {
      return true;
    }
    return hashed_password.length;
  }, 'Password cannot be blank');
  UserSchema.pre('save', function(next){
    if (!this.isNew) {
      return next();
    }
    if (!validatePresenceOf(this.password) && authTypes.indexOf(this.provider) === -1) {
      next(new Error('Invalid password'));
    } else {
      next();
    }
  });
  UserSchema.methods = {
    authenticate: function(plainText){
      return this.encryptPassword(plainText) === this.hashed_password;
    },
    makeSalt: function(){
      return Math.round((new Date).valueOf() * Math.random()) + '';
    },
    encryptPassword: function(password){
      var encrypred, err;
      if (!password) {
        return '';
      }
      encrypred = undefined;
      try {
        encrypred = crypto.createHmac('sha1', this.salt).update(password).digest('hex');
        return encrypred;
      } catch (e$) {
        err = e$;
        return '';
      }
    }
  };
  module.exports = mongoose.model('User', UserSchema);
}).call(this);
